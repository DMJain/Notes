# Atomic Datatypes in Java

## Prerequisites
- [c5: Synchronization Problem](../c5_synchronization_problem/SynchronizationProblemNotes.md) â€” Race conditions
- [c6: Mutex Locks](../c6_mutex_locks/MutexLocksNotes.md) â€” ReentrantLock
- [c7: synchronized](../c7_synchronized_keyword/SynchronizedNotes.md) â€” Built-in locks

---

## What You'll Learn

| Question | Answer |
|----------|--------|
| **WHAT** | Lock-free, thread-safe operations using hardware-level atomicity |
| **WHY** | Faster than locks for simple operations (no blocking!) |
| **WHEN** | Simple atomic operations like counters, flags, references |
| **HOW** | `java.util.concurrent.atomic` package: `AtomicInteger`, `AtomicLong`, etc. |

---

## WHY Atomic Types?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     THE PROBLEM WITH LOCKS                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   Using synchronized or ReentrantLock for a simple counter:                  â”‚
â”‚                                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚   synchronized (lock) {                                              â”‚   â”‚
â”‚   â”‚       count++;  â† We're using a HEAVY lock for ONE tiny operation!   â”‚   â”‚
â”‚   â”‚   }                                                                  â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚   Problems:                                                          â”‚   â”‚
â”‚   â”‚   â€¢ Lock acquisition overhead                                        â”‚   â”‚
â”‚   â”‚   â€¢ Thread blocking (context switching)                              â”‚   â”‚
â”‚   â”‚   â€¢ Risk of deadlock                                                 â”‚   â”‚
â”‚   â”‚   â€¢ Reduced parallelism                                              â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â”‚   ğŸ’¡ For simple operations, we want something LIGHTER!                      â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## The Solution: Atomic Types

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       ATOMIC = NO LOCKS!                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   Instead of locking, use HARDWARE-LEVEL atomic operations:                  â”‚
â”‚                                                                              â”‚
â”‚   AtomicInteger count = new AtomicInteger(0);                                â”‚
â”‚   count.incrementAndGet();  // Atomic! No lock needed!                       â”‚
â”‚                                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚   HOW IT WORKS: Compare-And-Swap (CAS)                               â”‚   â”‚
â”‚   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                               â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚   CPU has a special instruction: CMPXCHG (Compare and Exchange)      â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚   CAS(memory_location, expected_value, new_value):                   â”‚   â”‚
â”‚   â”‚   1. Read current value from memory                                  â”‚   â”‚
â”‚   â”‚   2. If current == expected:                                         â”‚   â”‚
â”‚   â”‚         â†’ Write new_value to memory (SUCCESS)                        â”‚   â”‚
â”‚   â”‚      Else:                                                           â”‚   â”‚
â”‚   â”‚         â†’ Don't write, return failure (RETRY)                        â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚   This is ONE CPU instruction â†’ Cannot be interrupted!               â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Compare-And-Swap (CAS) Visualized

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         CAS IN ACTION                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   Goal: Increment count from 5 to 6                                          â”‚
â”‚                                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  SUCCESSFUL CAS:                                                     â”‚   â”‚
â”‚   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                     â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚  Memory:  [count = 5]                                                â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚  Thread A: "CAS(count, expected=5, new=6)"                           â”‚   â”‚
â”‚   â”‚            â†’ Read count: 5                                           â”‚   â”‚
â”‚   â”‚            â†’ Is 5 == 5? YES!                                         â”‚   â”‚
â”‚   â”‚            â†’ Write 6 to count                                        â”‚   â”‚
â”‚   â”‚            â†’ Return: SUCCESS âœ…                                       â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚  Memory:  [count = 6]                                                â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  FAILED CAS (Another thread changed the value):                      â”‚   â”‚
â”‚   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                     â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚  Memory:  [count = 5]                                                â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚  Thread A: Read count = 5, prepares CAS(5â†’6)                        â”‚   â”‚
â”‚   â”‚  Thread B: [sneaks in] count = 7                                    â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚  Thread A: "CAS(count, expected=5, new=6)"                           â”‚   â”‚
â”‚   â”‚            â†’ Read count: 7                                           â”‚   â”‚
â”‚   â”‚            â†’ Is 7 == 5? NO!                                          â”‚   â”‚
â”‚   â”‚            â†’ Don't write, return: FAILED âŒ                          â”‚   â”‚
â”‚   â”‚            â†’ RETRY with new value                                    â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â”‚   KEY INSIGHT: No lock! Failed threads just RETRY, not blocked.              â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Available Atomic Classes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  java.util.concurrent.atomic                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   PRIMITIVE WRAPPERS:                                                        â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                       â”‚
â”‚   AtomicInteger       â† Most common, for int counters                        â”‚
â”‚   AtomicLong          â† For long values                                      â”‚
â”‚   AtomicBoolean       â† For boolean flags                                    â”‚
â”‚                                                                              â”‚
â”‚   REFERENCE TYPES:                                                           â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                          â”‚
â”‚   AtomicReference<V>  â† For object references                                â”‚
â”‚   AtomicStampedReference<V> â† Reference + version stamp (ABA problem)        â”‚
â”‚   AtomicMarkableReference<V> â† Reference + boolean mark                      â”‚
â”‚                                                                              â”‚
â”‚   ARRAYS:                                                                    â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€                                                                   â”‚
â”‚   AtomicIntegerArray  â† Array of atomic integers                             â”‚
â”‚   AtomicLongArray     â† Array of atomic longs                                â”‚
â”‚   AtomicReferenceArray<V> â† Array of atomic references                       â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## AtomicInteger Methods

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      AtomicInteger API                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   CREATION:                                                                  â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                 â”‚
â”‚   AtomicInteger ai = new AtomicInteger();      // 0                          â”‚
â”‚   AtomicInteger ai = new AtomicInteger(10);    // 10                         â”‚
â”‚                                                                              â”‚
â”‚   GET/SET:                                                                   â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€                                                                  â”‚
â”‚   int value = ai.get();                 // Get current value                 â”‚
â”‚   ai.set(20);                           // Set new value                     â”‚
â”‚                                                                              â”‚
â”‚   INCREMENT/DECREMENT:                                                       â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                     â”‚
â”‚   int newVal = ai.incrementAndGet();    // ++i (returns new value)           â”‚
â”‚   int oldVal = ai.getAndIncrement();    // i++ (returns old value)           â”‚
â”‚   int newVal = ai.decrementAndGet();    // --i                               â”‚
â”‚   int oldVal = ai.getAndDecrement();    // i--                               â”‚
â”‚                                                                              â”‚
â”‚   ADD:                                                                       â”‚
â”‚   â”€â”€â”€â”€                                                                      â”‚
â”‚   int newVal = ai.addAndGet(5);         // i += 5 (returns new)              â”‚
â”‚   int oldVal = ai.getAndAdd(5);         // returns old, then adds 5          â”‚
â”‚                                                                              â”‚
â”‚   COMPARE-AND-SET (CAS):                                                     â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                    â”‚
â”‚   boolean success = ai.compareAndSet(expected, update);                      â”‚
â”‚   // Returns true if current == expected and update happened                 â”‚
â”‚   // Returns false if current != expected (no update)                        â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Fixing Adder-Subtractor with AtomicInteger

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0);
    
    public void increment() {
        count.incrementAndGet();  // Atomic! No lock!
    }
    
    public void decrement() {
        count.decrementAndGet();  // Atomic! No lock!
    }
    
    public int getCount() {
        return count.get();
    }
}
```

**Compare to synchronized:**

```java
// synchronized (c7)            // AtomicInteger (c8)
synchronized void increment() { void increment() {
    count++;                        count.incrementAndGet();
}                               }

// Heavy lock overhead          // Lightweight CAS operation
// Thread blocking              // Thread retries (no blocking)
```

---

## When to Use Atomic vs synchronized

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  DECISION GUIDE                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚                   Is operation single-variable and simple?                   â”‚
â”‚                              (counter, flag)                                 â”‚
â”‚                                     â”‚                                        â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚                    YES                               NO                      â”‚
â”‚                    â”‚                                 â”‚                      â”‚
â”‚                    â–¼                                 â–¼                      â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    Need multiple variables       â”‚
â”‚              â”‚  ATOMIC   â”‚                    or complex logic?             â”‚
â”‚              â”‚   types   â”‚                           â”‚                      â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚                                               YES           (complex)       â”‚
â”‚                                               â”‚                             â”‚
â”‚                                               â–¼                             â”‚
â”‚                                        synchronized                         â”‚
â”‚                                        or ReentrantLock                     â”‚
â”‚                                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  USE ATOMIC FOR:                                                     â”‚   â”‚
â”‚   â”‚  â€¢ Counters, statistics                                              â”‚   â”‚
â”‚   â”‚  â€¢ Boolean flags                                                     â”‚   â”‚
â”‚   â”‚  â€¢ Single reference updates                                          â”‚   â”‚
â”‚   â”‚  â€¢ Read-modify-write on ONE variable                                 â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚  USE LOCKS FOR:                                                      â”‚   â”‚
â”‚   â”‚  â€¢ Updating MULTIPLE related variables together                      â”‚   â”‚
â”‚   â”‚  â€¢ Complex invariants (e.g., balance + transaction log)              â”‚   â”‚
â”‚   â”‚  â€¢ When you need to read multiple values atomically                  â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Common Gotchas

### âŒ Compound Operations Are NOT Atomic

```java
AtomicInteger count = new AtomicInteger(0);

// âŒ NOT ATOMIC! Two separate operations!
if (count.get() == 0) {      // Operation 1
    count.set(10);           // Operation 2 - another thread can change between!
}

// âœ… Use compareAndSet for atomic check-then-update
boolean success = count.compareAndSet(0, 10);  // ONE atomic operation
```

### âŒ Using Atomic for Multiple Variables

```java
AtomicInteger balance = new AtomicInteger(100);
AtomicInteger txCount = new AtomicInteger(0);

// âŒ NOT SAFE! Two separate atomic operations!
void withdraw(int amount) {
    balance.addAndGet(-amount);  // Step 1
    txCount.incrementAndGet();   // Step 2 - another thread sees inconsistent state!
}

// âœ… Use synchronized or lock for multi-variable updates
synchronized void withdraw(int amount) {
    balance -= amount;
    txCount++;  // Both update atomically
}
```

---

## Performance Comparison

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  PERFORMANCE (Rough Comparison)                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   LOW CONTENTION (few threads, rare conflicts):                              â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                             â”‚
â”‚   AtomicInteger   â‰ˆ synchronized  â‰ˆ  ReentrantLock                          â”‚
â”‚   (All perform similarly)                                                    â”‚
â”‚                                                                              â”‚
â”‚   HIGH CONTENTION (many threads, frequent conflicts):                        â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                       â”‚
â”‚   AtomicInteger  >>  synchronized  â‰ˆ  ReentrantLock                         â”‚
â”‚   (Atomic is MUCH faster - no blocking!)                                     â”‚
â”‚                                                                              â”‚
â”‚   WHY?                                                                       â”‚
â”‚   â”€â”€â”€â”€                                                                      â”‚
â”‚   â€¢ Locks: Thread must WAIT (blocked, context switch)                       â”‚
â”‚   â€¢ Atomic: Thread retries CAS (no blocking, stays on CPU)                  â”‚
â”‚                                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  Lock:    Thread A â”‚â”€â”€â”€â”€â”€â”€BLOCKEDâ”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€continueâ”€â”€â”€â–º            â”‚   â”‚
â”‚   â”‚           Thread B â”‚â”€â”€â”€â”€â”€â”€â”€â”€WORKâ”€â”€â”€â”€â”€â”€â”€â”‚                            â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚  Atomic:  Thread A â”‚â”€retryâ”€retryâ”€SUCCESSâ”€â”‚                          â”‚   â”‚
â”‚   â”‚           Thread B â”‚â”€â”€â”€â”€SUCCESSâ”€â”€â”€â”€â”‚                                 â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚  No blocking = Less overhead!                                        â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Summary

| Concept | Key Point |
|---------|-----------|
| **Atomic types** | Lock-free thread safety using hardware CAS |
| **CAS** | Compare-And-Swap: atomic read-modify-write in one CPU instruction |
| **AtomicInteger** | Most common, for counters and statistics |
| **incrementAndGet()** | Atomic i++, returns new value |
| **compareAndSet()** | Atomic check-then-update |
| **No blocking** | Failed threads retry immediately instead of waiting |

### The Big Picture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SYNCHRONIZATION OPTIONS                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   c6: ReentrantLock                                                          â”‚
â”‚       â””â”€ Explicit lock/unlock, tryLock, fairness                            â”‚
â”‚       â””â”€ Use when: advanced features needed                                  â”‚
â”‚                                                                              â”‚
â”‚   c7: synchronized                                                           â”‚
â”‚       â””â”€ Auto-unlock, simpler code                                          â”‚
â”‚       â””â”€ Use when: simple mutual exclusion                                  â”‚
â”‚                                                                              â”‚
â”‚   c8: Atomic types  â† YOU ARE HERE                                          â”‚
â”‚       â””â”€ Lock-free, hardware CAS                                            â”‚
â”‚       â””â”€ Use when: simple single-variable operations                        â”‚
â”‚                                                                              â”‚
â”‚   NEXT: c9 volatile - for visibility only (not atomicity!)                  â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Project Demo Structure

```
c8_atomic_datatypes/
â”œâ”€â”€ AtomicDatatypesNotes.md    â† You are here
â”œâ”€â”€ Main.java
â”œâ”€â”€ contracts/
â”‚   â””â”€â”€ IAtomicCounter.java
â”œâ”€â”€ impl/
â”‚   â””â”€â”€ AtomicIntegerCounter.java
â””â”€â”€ runner/
    â”œâ”€â”€ AtomicRunner.java
    â””â”€â”€ scenarios/
        â”œâ”€â”€ AtomicDemo.java
        â””â”€â”€ CASScenario.java
```

---

## Next Chapter
â†’ [c9: volatile keyword](../c9_volatile_keyword/VolatileNotes.md) â€” Memory visibility guarantee
